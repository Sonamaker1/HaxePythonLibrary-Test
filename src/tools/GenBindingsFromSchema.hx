package tools;

import haxe.Json;
import sys.FileSystem;
import sys.io.File;

class GenBindingsFromSchema {
  static function main() {
    final moduleName = "hxpy_ext";
    final schemaPath = "gen/py_schema.json";
    final outPath = "native/bindings.cpp";
    final includeDir = "gen/cpp/include";

    if (!FileSystem.exists(schemaPath)) {
      Sys.println("ERROR: Missing " + schemaPath + " (schema macro didn't run?)");
      Sys.exit(1);
    }

    if (!FileSystem.exists("native")) FileSystem.createDirectory("native");

    final schema:Dynamic = Json.parse(File.getContent(schemaPath));

    final headers:Array<String> = [];
    if (FileSystem.exists(includeDir)) {
      for (f in FileSystem.readDirectory(includeDir)) {
        if (StringTools.endsWith(f.toLowerCase(), ".h")) headers.push(f);
      }
    }

    final cpp = new StringBuf();
    cpp.add("// AUTO-GENERATED by tools.GenBindingsFromSchema.hx\n\n");
    cpp.add('#include <pybind11/pybind11.h>\n');
    cpp.add('#include <pybind11/stl.h>\n');
    cpp.add('#include <deque>\n#include <memory>\n#include <string>\n\n');
    cpp.add("namespace py = pybind11;\n\n");

    // Include *all* generated headers (robust to hxpy_Api.h naming)
    for (h in headers) cpp.add('#include "' + h + '"\n');
    cpp.add("\n");

    // reflaxe Array<T> helper: shared_ptr<deque<T>>
    cpp.add("template <typename T>\n");
    cpp.add("static const std::deque<T>& _hx_deref(const std::shared_ptr<std::deque<T>>& p) {\n");
    cpp.add("  static const std::deque<T> empty;\n");
    cpp.add("  return p ? *p : empty;\n");
    cpp.add("}\n\n");

    // Forward declarations for all converters (fixes order dependency)
    cpp.add("// Forward declarations for generated converters\n");
    for (cls in (schema.classes : Array<Dynamic>)) {
      final haxeName:String = cls.name;
      final cppName:String  = cls.cppName;
      final fn = "to_python_" + haxeName.split(".").join("_");
      cpp.add("static py::object " + fn + "(const " + cppName + "& v);\n");
    }
    cpp.add("\n");

    // Emit all converters
    for (cls in (schema.classes : Array<Dynamic>)) {
      cpp.add(genToPython(cls));
      cpp.add("\n");
    }

    // Emit module exports (schema-driven)
    cpp.add('PYBIND11_MODULE(' + moduleName + ', m) {\n');
    cpp.add('  m.doc() = "Auto-generated bindings from Haxe schema (@:pyDict + @:pyExport)";\n\n');

    final exports:Array<Dynamic> = (schema.exports != null) ? cast schema.exports : [];
    for (e in exports) {
      cpp.add(genModuleExport(e));
    }

    cpp.add("}\n");

    File.saveContent(outPath, cpp.toString());
    Sys.println("Wrote " + outPath);
  }

  // ----------------------------
  // Type -> dict converters
  // ----------------------------

  static function genToPython(cls:Dynamic):String {
    final haxeName:String = cls.name;     // hxpy.ComplexData
    final cppName:String  = cls.cppName;  // hxpy::ComplexData
    final fn = "to_python_" + haxeName.split(".").join("_");

    final out = new StringBuf();
    out.add("static py::object " + fn + "(const " + cppName + "& v) {\n");
    out.add("  py::dict d;\n");

    for (f in (cls.fields : Array<Dynamic>)) {
      out.add(genField(f.pyName, f.name, f.type));
    }

    out.add("  return std::move(d);\n");
    out.add("}\n");
    return out.toString();
  }

  static function genField(pyName:String, fieldName:String, t:Dynamic):String {
    return switch (t.kind) {
      case "int" | "float" | "bool":
        '  d["' + pyName + '"] = v.' + fieldName + ';\n';

      case "string" | "String":
        '  d["' + pyName + '"] = py::str(v.' + fieldName + ');\n';

      case "object":
        // Defensive: schema might still encode String as object
        if (t.name == "String" || t.name == "string") {
          '  d["' + pyName + '"] = py::str(v.' + fieldName + ');\n';
        } else {
          final fn = "to_python_" + (t.name : String).split(".").join("_");
          '  d["' + pyName + '"] = ' + fn + '(v.' + fieldName + ');\n';
        }

      case "array":
        final elemExpr = genElemExpr(t.elem, "e");
        var s = "";
        s += "  {\n";
        s += "    py::list lst;\n";
        s += "    for (const auto& e : _hx_deref(v." + fieldName + ")) {\n";
        s += "      lst.append(" + elemExpr + ");\n";
        s += "    }\n";
        s += '    d["' + pyName + '"] = std::move(lst);\n';
        s += "  }\n";
        s;

      default:
        '  /* unsupported field: ' + fieldName + ' */\n';
    }
  }

  static function genElemExpr(t:Dynamic, varName:String):String {
    return switch (t.kind) {
      case "int" | "float" | "bool":
        varName;

      case "string" | "String":
        "py::str(" + varName + ")";

      case "object":
        if (t.name == "String" || t.name == "string") {
          "py::str(" + varName + ")";
        } else {
          final fn = "to_python_" + (t.name : String).split(".").join("_");
          fn + "(" + varName + ")";
        }

      default:
        varName;
    }
  }

  // ----------------------------
  // Exports generation
  // ----------------------------

  static function genModuleExport(exp:Dynamic):String {
    // Expected schema format:
    // {
    //   pyName: "hexToRGB",
    //   hxName: "hexToRGB",
    //   cppOwner: "hxpy::Api",
    //   args: [{ name:"hexIn", type:{kind:"int"} }],
    //   ret: { kind:"array", elem:{kind:"string"} }
    // }
    final pyName:String = exp.pyName;
    final hxName:String = exp.hxName;
    final cppOwner:String = exp.cppOwner;

    final args:Array<Dynamic> = (exp.args != null) ? cast exp.args : [];
    final ret:Dynamic = exp.ret;

    final params = new Array<String>();
    final callArgs = new Array<String>();
    final pyArgs = new Array<String>();

    for (a in args) {
      final an:String = a.name;
      final cppT = schemaTypeToCppParamType(a.type);
      params.push(cppT + " " + an);
      callArgs.push(an);
      pyArgs.push('py::arg("' + an + '")');
    }

    final paramList = params.join(", ");
    final callList = callArgs.join(", ");
    final pyArgList = (pyArgs.length > 0) ? (", " + pyArgs.join(", ")) : "";

    final callExpr = cppOwner + "::" + hxName + "(" + callList + ")";

    // If return is a simple primitive/bool, bind directly as a function pointer.
    if (isDirectReturn(ret)) {
      return '  m.def("' + pyName + '", &' + cppOwner + "::" + hxName + pyArgList + ');\n';
    }

    // Otherwise wrap in a lambda that converts the return value.
    final body = genReturnWrapperBody(ret, callExpr);
    return '  m.def("' + pyName + '", [](' + paramList + '){ ' + body + ' }' + pyArgList + ');\n';
  }

  static function isDirectReturn(ret:Dynamic):Bool {
    if (ret == null || ret.kind == null) return false;
    return switch (ret.kind) {
      case "int" | "float" | "bool":
        true;
      default:
        false;
    }
  }

  static function genReturnWrapperBody(ret:Dynamic, callExpr:String):String {
    if (ret == null || ret.kind == null) {
      return '(void)' + callExpr + '; return py::none();';
    }

    return switch (ret.kind) {
      case "int" | "float" | "bool":
        // Should have been direct, but keep safe
        "return " + callExpr + ";";

      case "string" | "String":
        'auto r = ' + callExpr + '; return py::str(r);';

      case "object":
        if (ret.name == "String" || ret.name == "string") {
          'auto r = ' + callExpr + '; return py::str(r);';
        } else {
          final fn = "to_python_" + (ret.name : String).split(".").join("_");
          'auto r = ' + callExpr + '; return ' + fn + '(r);';
        }

      case "array":
        final elemExpr = genElemExpr(ret.elem, "e");
        var s = "";
        s += 'auto r = ' + callExpr + ';\n';
        s += '    py::list lst;\n';
        s += '    for (const auto& e : _hx_deref(r)) {\n';
        s += '      lst.append(' + elemExpr + ');\n';
        s += '    }\n';
        s += '    return lst;';
        s;

      default:
        '(void)' + callExpr + '; return py::none();';
    }
  }

  static function schemaTypeToCppParamType(t:Dynamic):String {
    // This controls how we accept args from Python into the lambda wrapper.
    // Keep it conservative; you can extend later.
    if (t == null || t.kind == null) return "py::object";

    return switch (t.kind) {
      case "int":
        "int";
      case "float":
        "double";
      case "bool":
        "bool";
      case "string" | "String":
        "const std::string&";

      // For now we don't auto-convert complex args from Python -> Haxe.
      // You can add from_python_* later.
      default:
        "py::object";
    }
  }
}
