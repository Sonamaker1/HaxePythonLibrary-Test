package tools;

import haxe.Json;
import sys.FileSystem;
import sys.io.File;

class GenBindingsFromSchema {
  static function main() {
    final moduleName = "hxpy_ext";
    final schemaPath = "gen/py_schema.json";
    final outPath = "native/bindings.cpp";
    final includeDir = "gen/cpp/include";

    if (!FileSystem.exists(schemaPath)) {
      Sys.println("ERROR: Missing " + schemaPath + " (schema macro didn't run?)");
      Sys.exit(1);
    }

    if (!FileSystem.exists("native")) FileSystem.createDirectory("native");

    final schema:Dynamic = Json.parse(File.getContent(schemaPath));

    final headers:Array<String> = [];
    if (FileSystem.exists(includeDir)) {
      for (f in FileSystem.readDirectory(includeDir)) {
        if (StringTools.endsWith(f.toLowerCase(), ".h")) headers.push(f);
      }
    }

    final cpp = new StringBuf();
    cpp.add("// AUTO-GENERATED by tools.GenBindingsFromSchema.hx\n\n");
    cpp.add('#include <pybind11/pybind11.h>\n');
    cpp.add('#include <pybind11/stl.h>\n');
    cpp.add('#include <deque>\n#include <memory>\n#include <string>\n\n');
    cpp.add("namespace py = pybind11;\n\n");

    // Include *all* generated headers (robust to hxpy_Api.h naming)
    for (h in headers) cpp.add('#include "' + h + '"\n');
    cpp.add("\n");

    // reflaxe Array<T> helper: shared_ptr<deque<T>>
    cpp.add("template <typename T>\n");
    cpp.add("static const std::deque<T>& _hx_deref(const std::shared_ptr<std::deque<T>>& p) {\n");
    cpp.add("  static const std::deque<T> empty;\n");
    cpp.add("  return p ? *p : empty;\n");
    cpp.add("}\n\n");

    // Forward declarations for all converters (fixes order dependency)
    cpp.add("// Forward declarations for generated converters\n");
    for (cls in (schema.classes : Array<Dynamic>)) {
      final haxeName:String = cls.name;
      final cppName:String  = cls.cppName;
      final fn = "to_python_" + haxeName.split(".").join("_");
      cpp.add("static py::object " + fn + "(const " + cppName + "& v);\n");
    }
    cpp.add("\n");

    // Emit all converters
    for (cls in (schema.classes : Array<Dynamic>)) {
      cpp.add(genToPython(cls));
      cpp.add("\n");
    }

    // Emit module exports (still hardcoded; can be schema-driven later)
    cpp.add('PYBIND11_MODULE(' + moduleName + ', m) {\n');
    cpp.add('  m.doc() = "Auto-generated bindings from Haxe @:pyDict schema";\n\n');
    cpp.add('  m.def("add", &hxpy::Api::add, py::arg("a"), py::arg("b"));\n');
    cpp.add('  m.def("build_complex", [](){ auto d = hxpy::Api::buildComplex(); return to_python_hxpy_ComplexData(d); });\n');
    cpp.add("}\n");

    File.saveContent(outPath, cpp.toString());
    Sys.println("Wrote " + outPath);
  }

  static function genToPython(cls:Dynamic):String {
    final haxeName:String = cls.name;     // hxpy.ComplexData
    final cppName:String  = cls.cppName;  // hxpy::ComplexData
    final fn = "to_python_" + haxeName.split(".").join("_");

    final out = new StringBuf();
    out.add("static py::object " + fn + "(const " + cppName + "& v) {\n");
    out.add("  py::dict d;\n");

    for (f in (cls.fields : Array<Dynamic>)) {
      out.add(genField(f.pyName, f.name, f.type));
    }

    out.add("  return std::move(d);\n");
    out.add("}\n");
    return out.toString();
  }

  static function genField(pyName:String, fieldName:String, t:Dynamic):String {
    return switch (t.kind) {
      case "int" | "float" | "bool":
        '  d["' + pyName + '"] = v.' + fieldName + ';\n';

      // IMPORTANT FIX:
      // Never call to_python_String(...) â€” just wrap with py::str(...)
      case "string"|"String":
        '  d["' + pyName + '"] = py::str(v.' + fieldName + ');\n';

      case "object":
        if(t.name == "String" || t.name == "string"){ 
          // Special case: reflaxe String type
          return '  d["' + pyName + '"] = py::str(v.' + fieldName + ');\n';
        }
        else{
          final fn = "to_python_" + (t.name : String).split(".").join("_");
          '  d["' + pyName + '"] = ' + fn + '(v.' + fieldName + ');\n';
        }

      case "array":
        final elemExpr = genElemExpr(t.elem, "e");
        var s = "";
        s += "  {\n";
        s += "    py::list lst;\n";
        s += "    for (const auto& e : _hx_deref(v." + fieldName + ")) {\n";
        s += "      lst.append(" + elemExpr + ");\n";
        s += "    }\n";
        s += '    d["' + pyName + '"] = std::move(lst);\n';
        s += "  }\n";
        s;

      default:
        '  /* unsupported field: ' + fieldName + ' */\n';
    }
  }

  static function genElemExpr(t:Dynamic, varName:String):String {
    return switch (t.kind) {
      case "int" | "float" | "bool":
        varName;

      case "string":
        "py::str(" + varName + ")";

      case "object":
        final fn = "to_python_" + (t.name : String).split(".").join("_");
        fn + "(" + varName + ")";

      default:
        varName;
    }
  }
}
